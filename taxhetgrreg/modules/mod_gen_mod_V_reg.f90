module mod_gen_mod_V_reg
!This module contains subroutine for generating module mod_V_reg.f90.

use mod_types
use mod_par
use mod_parameters_hard
use mod_tools

implicit none

contains

!Subroutine gen_mod_V_reg generates the whole module mod_V_reg.f90, which includes
!functions approximating V, which are generated based on parameters in parameter
!file (gen_mode_V_reg, and parameters with prefix 'GAF').
!To use these the program has to be recompiled using the new module.
subroutine gen_mod_V_reg(GAF_names,GAF_states,pars,folder_name,st_und_img,s_ind_img,&
min_ind_img,max_ind_img,i_img,spec_img,fs_mean,fs_norm,fs_min,fs_max,v_num_el)
    character(len=*), dimension(:), intent(in) :: GAF_names,GAF_states
    character(len=*), intent(in) :: folder_name
    type(par), intent(in) :: pars
    real(dp), dimension(4,min_ind_img:max_ind_img) :: st_und_img
    integer, dimension(min_ind_img:max_ind_img) :: s_ind_img
    integer, intent(in) :: min_ind_img,max_ind_img
    integer, intent(in) :: i_img,spec_img
    integer, intent(in) :: V_num_el

    character(len = 256) :: full_path !full path file name

    character(len = 256) :: string1,string2,string3,string4,string5,string6,string7
    character :: aster

    integer, dimension(2) :: shape_GAF_deg

    integer :: st_ind,func_ind !indices for cycling over states and functions
    integer :: st1,st2,st3,st4 !cycling over individual states
    integer :: num_exp_var !number of explanatory variables in regressions
    integer :: st_counter

    integer :: exp_var_ind !index of explanatory variable
    integer :: max_deg

    real(dp), codimension[*] :: FS_mean,FS_norm,fs_min,fs_max
    integer :: gp_ind,img_ind
    real(dp) :: y_val

    !logical :: exp_var_first

    integer, allocatable, dimension(:,:) :: st_deg_indices !array whose element (st_ind,deg) contains index
    !of explanatory variable which is the degree deg of underlying state with index st_ind. This is used
    !so that we use pre-computed results to as large extent as possible (with interaction terms
    !there could be further gains but a bit annoying to code and mistakes could be made).

    !Most of the statements are done by image 1 only. The other images are used only for computing some
    !statistics used in feature scaling.

    if(i_img == spec_img) then

    !First create the full path for the module.
    full_path = 'results/'//trim(folder_name)//'/mod_V_reg.f90'

    !Create the module file
    open(unit=21, file = trim(full_path), status = 'replace')
    write(21,'(A)') 'module mod_V_reg'
    write(21,'(A)') '!(file mod_V_reg.f90 automatically generated by subroutine gen_mod_V_reg)'
    write(21,'(A)') ' '

    write(21,'(A)') '!Module mod_V_reg contains hard-coded constants and functional expressions which determine'
    write(21,'(A)') '!how the value function is approximated. This module is the only thing that needs to be'
    write(21,'(A)') '!changed when we change the set of explanatory variables (used to approximate value function).'

    write(21,'(A)') ' '
    write(21,'(A)') 'use mod_types'
    write(21,'(A)') 'use mod_parameters_hard'
    write(21,'(A)') ' '
    write(21,'(A)') 'implicit none'

    write(21,'(A)') ' '
    write(21,'(A)') '!Definitions of variables'
    write(21,'(A)') ' '
    write(21,'(A)') '!V_exp_num is the number of explanatory variables in the regressions (including the constant term'
    write(21,'(A)') '!if it is present and excluding the (M_par - 1) shock realization dummies which are always present).'
    write(21,'(A)') '!This has to correspond to the actual number of variables defined in the functions/'
    write(21,'(A)') '!subroutines below. V_exp_num_dyn is the number of variables in the dynamic case.'

    end if

    !Get the total number of variables in the approximating functions (this depends on the value of basis)
    shape_GAF_deg = shape(pars%GAF_deg) !first index is the number of functions, 2nd index the number of states

    if(i_img == spec_img) then
    !The following part doesn't save any results needed by other images, it's only used by image 1
    !to generate source code related to number of explanatory variables.

    do func_ind = 1,shape_GAF_deg(1) !cycle over functions to be approximated
        !number of explanatory variables in each regression
        num_exp_var = 0 !(the constant term is the first element)
        select case(pars%GAF_basis(1,func_ind))
            case(1,2,3,4) !tensor product(1) or complete polynomials (2)
                !the number of variables depends on GAF_basis,GAF_deg,GAF_inter_deg
                !Because we're not using all the terms in interactions based on restrictions in
                !GAF_inter_deg, cycle over all states and their degrees. At this point this assumes
                !a concrete number of underlying states, but it can be generalized quite easily
                !(as when we cycled over a single index in sharing value function accross images, where
                !the one index was then unfolded).
                !(3) is tensor product of Cheb pol, and (4) is Complete cheb pol (same as (2) but Cheb pol
                !of individual variables rather than standard polynomials.

                !If complete polynomials, also get the restriction on sum of degrees K_res,
                !where K_res is the largest degree of polynomial of individual state (max_deg)
                !Same for complete Cheb pol.
                if(pars%GAF_basis(1,func_ind) == 2 .or. pars%GAF_basis(1,func_ind) == 4) then
                    max_deg = maxval(reshape(pars%GAF_deg(func_ind,:),[4]))
                end if

                do st1=0,pars%GAF_deg(func_ind,1)
                do st2=0,pars%GAF_deg(func_ind,2)
                do st3=0,pars%GAF_deg(func_ind,3)
                do st4=0,pars%GAF_deg(func_ind,4)
                    !If the order of the polynomial in interaction term is larger
                    !than GAF_inter_deg, don't increase the number go to 555:

                    !If at least 2 of the degrees are positive, check the restriction on order of interaction
                    !term
                    if(sum([L_to_I(st1>0),L_to_I(st2>0),L_to_I(st3>0),L_to_I(st4>0)]) > 1) then

                    !the -1 value means no restriction. If any of the restrictions is violated, go to 555
                    if(any([st1>pars%GAF_inter_deg(func_ind,1) .and. pars%GAF_inter_deg(func_ind,1) > -1,&
                    st2>pars%GAF_inter_deg(func_ind,2) .and. pars%GAF_inter_deg(func_ind,2) > -1,&
                    st3>pars%GAF_inter_deg(func_ind,3) .and. pars%GAF_inter_deg(func_ind,3) > -1,&
                    st4>pars%GAF_inter_deg(func_ind,4) .and. pars%GAF_inter_deg(func_ind,4) > -1])) then
                        go to 555
                    end if

                    !If complete polynomials, also check that the sum of degrees is not greater than K,
                    !where K is the largest individual degree.
                    if((pars%GAF_basis(1,func_ind)==2 .or. pars%GAF_basis(1,func_ind)==4) &
                     .and. (st1 + st2 + st3 + st4) > max_deg) go to 555

                    end if
                    num_exp_var = num_exp_var + 1
                555 end do
                end do
                end do
                end do

            write(string1,*) num_exp_var !(write the number of variables)
            !Here hardcoded the names of the parameters in the module. This is due to inconsistency
            !in naming, so the number of explanatory vars isn't just the name of the function with a suffix.
            if(func_ind == 1) then
                write(21,'(A)') 'integer, parameter :: V_exp_num = '//trim(adjustl(string1))
            else
                write(21,'(A)') 'integer, parameter :: V_exp_num_dyn = '//trim(adjustl(string1))
            end if

            case default
                write(*,*) 'Error: wrong value of GAF_basis in gen_mod_V_Reg'
                error stop
        end select

        !Generate the initialization statement
    end do


    write(21,'(A)') '!V_reg_basis is the GAF_basis in parameter file which was used to generate this file.'
    write(21,'(A)') '!We save this here because the value in parameter file may have changed since generating'
    write(21,'(A)') '!this module, and particularly since this module was compiled. Therefore, using the value'
    write(21,'(A)') '!in the parameter file could lead to errors. Some parts of the program depend on what basis'
    write(21,'(A)') '!was used. For example, if we are using Cheb. pol., then states are normalized into 0,1 interval.'
    string1 = '['
    do func_ind = 1,shape_GAF_deg(1)
        write(string2,'(I3)') pars%GAF_basis(1,func_ind)
        string1 = trim(string1)//adjustl(string2)
        if(func_ind /= shape_GAF_deg(1)) string1 = trim(string1)//','
    end do
    string1 = trim(string1)//']'
    write(string2,'(I3)') shape_GAF_deg(1) !number of approximating functions
    string1 = 'integer, dimension('//trim(adjustl(string2))//'), parameter :: V_reg_basis = '//trim(string1)
    write(21,'(A)') ' '
    write(21,*) trim(adjustl(string1))


    write(21,'(A)') ' '
    write(21,'(A)') '!(GEN: in the later project with 4 value function, there will be 4 separate constants V1_exp_num,...,V4_exp_num).'
    write(21,'(A)') ' '
    write(21,'(A)') 'contains'
    write(21,'(A)') ' '

    write(21,'(A)') '!function V_und_exp transforms the underlying states (those that appear in the recursive formulation)'
    write(21,'(A)') '!into their functions which serve as explanatory variables in the regressions approximating the value'
    write(21,'(A)') '!function. V_und_exp_dyn is the version for dynamic case.'
    write(21,'(A)') '!(GEN: in the later project, there will be 4 subroutines: V1_und_exp,...,V4_und_exp)'
    write(21,'(A)') '!To help avoid mistakes, the inputs of this subroutine suggest which state they represent (consistent'
    write(21,'(A)') '!with notation used in the recursive formulation).'

    !Here generate the functions (including interface).
    do func_ind = 1,shape_GAF_deg(1) !cycle over functions to be approximated
        !Generate interface (this does not depend on the basis)
        st_counter = 0
        string1 = 'function '//trim(GAF_names(func_ind))//'('
        do st_ind = 1,shape_GAF_deg(2)
            !add the state into interface only if it's used
            if(pars%GAF_deg(func_ind,st_ind) > 0) then
                if(st_counter > 0) string1 = trim(string1)//','
                string1 = trim(string1)//trim(GAF_states(st_ind))
                st_counter = st_counter + 1
            end if
        end do
        string1 = trim(string1)//')'

        if(i_img == 1) then
        write(21,'(A)') trim(string1)

        !Finish generating the interface here:
        !Because of slight inconsistency in notation, write the first part manually
        if(func_ind == 1) then
            write(21,'(A)') '   real(dp), dimension(V_exp_num) :: '//trim(GAF_names(func_ind))
        else
            write(21,'(A)') '   real(dp), dimension(V_exp_num_dyn) :: '//trim(GAF_names(func_ind))
        end if


        do st_ind = 1,shape_GAF_deg(2)
            !add the state into interface only if it's used
            if(pars%GAF_deg(func_ind,st_ind) > 0) then
                string1 = '   real(dp), intent(in) :: '//trim(GAF_states(st_ind))
                write(21,'(A)') trim(string1)
            end if
        end do

        write(21,'(A)') '   !states explanatory in regression (functions of underlying states):'
        write(21,'(A)') ' '

        end if

        !Find the maximum degree of polynomial included.
        max_deg = maxval(reshape(pars%GAF_deg(func_ind,:),[4]))

        allocate(st_deg_indices(4,max_deg)) !allocate storage of index of degrees of underlying states
        st_deg_indices = 0
        exp_var_ind = 1 !initialize states counter


        select case(pars%GAF_basis(1,func_ind))
            case(1,2,3,4) !tensor product of polynomials or complete polynomials, or the same
            !but of Chebyshev polynomials (3 tensor, 4 complete).

            if(pars%GAF_basis(1,func_ind) == 1) then
                write(21,'(A)') '   !Tensor product (pars%GAF_basis = 1)'
            else if(pars%GAF_basis(1,func_ind) == 2) then
                write(21,'(A)') '   !Complete polynomials (pars%GAF_basis = 2)'
                write(21,'(A)') '   !K (sum of degreees) is the max. indiv. degree in pars%GAF_deg'
            else if(pars%GAF_basis(1,func_ind) == 3) then
                write(21,'(A)') '   !Tensor product of Cheb. pol. (pars%GAF_basis = 3)'
            else if(pars%GAF_basis(1,func_ind) == 4) then
                write(21,'(A)') '   !Tensor product of Cheb. pol. (pars%GAF_basis = 4)'
                write(21,'(A)') '   !K (sum of degreees) is the max. indiv. degree in pars%GAF_deg'
            end if

            if(pars%GAF_basis(1,func_ind) == 3 .or. pars%GAF_basis(1,func_ind) == 4) then
                write(21,'(A)') '   !The function assumes that the inputs were already projected onto [-1,1] interval.'
            end if


                do st4=0,pars%GAF_deg(func_ind,4)
                do st3=0,pars%GAF_deg(func_ind,3)
                do st2=0,pars%GAF_deg(func_ind,2)
                do st1=0,pars%GAF_deg(func_ind,1)

                    !If the order of the polynomial in interaction term is larger
                    !than GAF_inter_deg, don't increase the number go to 556:

                    !If complete polynomials, also check that the sum of degrees is not greater than K,
                    !where K is the largest individual degree (max_deg). If yes, then skip to the next
                    !candidate combination (go to 556)
                    if((pars%GAF_basis(1,func_ind)==2 .or. pars%GAF_basis(1,func_ind)==4) &
                     .and. (st1 + st2 + st3 + st4) > max_deg) go to 556

                    !If at least 2 of the degrees are positive, check the restriction on order of interaction
                    !term
                    if(sum([L_to_I(st1>0),L_to_I(st2>0),L_to_I(st3>0),L_to_I(st4>0)]) > 1) then

                        !the -1 value means no restriction. If any of the restrictions is violated, go to 556
                        if(any([st1>pars%GAF_inter_deg(func_ind,1) .and. pars%GAF_inter_deg(func_ind,1) > -1,&
                        st2>pars%GAF_inter_deg(func_ind,2) .and. pars%GAF_inter_deg(func_ind,2) > -1,&
                        st3>pars%GAF_inter_deg(func_ind,3) .and. pars%GAF_inter_deg(func_ind,3) > -1,&
                        st4>pars%GAF_inter_deg(func_ind,4) .and. pars%GAF_inter_deg(func_ind,4) > -1])) then
                            go to 556
                        end if

                    elseif(max(st1,st2,st3,st4)>0) then
                        !In this case exactly one degree is positive (not an interaction term)
                        !and it's not the constant term (at least one index > 0)
                        !save the index exp_var_ind
                        !max(st1,st2,st3,st4) - the degree of the polynomial with positive index.
                        if(st1 > 0) st_deg_indices(1,st1) = exp_var_ind
                        if(st2 > 0) st_deg_indices(2,st2) = exp_var_ind
                        if(st3 > 0) st_deg_indices(3,st3) = exp_var_ind
                        if(st4 > 0) st_deg_indices(4,st4) = exp_var_ind
                    end if
                    !If we got here then add the states, using st_deg_indices to access previous elements
                    !that contain lower degree polynomials

                    write(string2,'(I10)') exp_var_ind
                    string1 = '   '//trim(GAF_names(func_ind))//'('//trim(adjustl(string2))//') = '

                    !string2 will contain the actual expression used, string 3 will contain the
                    !full form (without using previously computed terms)
                    string2 = ''
                    string3 = '   !'
                    !for all 4 variables separately
                    aster = ' '
                    if(st1 > 0) then
                        write(string4,'(I10)') st1

                        !if degree>1, then use a previous expression
                        if(st1 > 1) then
                            !If this is an interaction term (one of the other degrees > 0), then
                            !we already have this degree of polynomial precomputed
                            if(st2>0 .or. st3>0 .or. st4> 0) then
                            write(string5,'(I10)') st_deg_indices(1,st1) !it's variable 1 we're dealing with
                            string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                            string2 = trim(string2)//trim(aster)//trim(string6)
                            else
                            !Otherwise just use the lower degree (by one) to compute the current degree

                            if(pars%GAF_basis(1,func_ind)<=2) then !standard pol
                            write(string5,'(I10)') st_deg_indices(1,st1-1) !it's variable 1 we're dealing with
                            string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                            string2 = trim(string2)//trim(aster)//trim(string6)//'*'//trim(GAF_states(1))
                            else  !Cheb pol
                                !If the degree is two, then the constant term (deg - 2) is not saved anywhere. In this
                                !case just write it manually. Otherwise get value of T_{-2} from previous expressions.
                                if(st1 > 2) then
                                    write(string5,'(I10)') st_deg_indices(1,st1-2)
                                else
                                    write(string5,'(I10)') 1 !element with index one constains the constant term
                                end if
                                write(string7,'(I10)') st_deg_indices(1,st1-1)
                                !string5 contains index term 2 degrees lower, string 7 one degree lower
                                !Get the actual terms (in string6 and string7)
                                string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                                string7 = trim(GAF_names(func_ind))//'('//trim(adjustl(string7))//')'
                                string2 = trim(string2)//trim(aster)//'2*'//trim(string7)//'*'//trim(GAF_states(1))&
                                //'-'//trim(string6)
                            end if

                            end if
                            string3 = trim(string3)//trim(aster)//trim(GAF_states(1))//'**'//trim(adjustl(string4))

                        else !don't use a previous expression.
                            string2 = trim(string2)//trim(aster)//trim(GAF_states(1))!//'**'//trim(adjustl(string4))
                            string3 = trim(string3)//trim(aster)//trim(GAF_states(1))
                        end if
                        aster = '*'
                    end if
                    !Repeat the same thing for the other underlying states:
                    if(st2 > 0) then
                        write(string4,'(I10)') st2
                        !if degree>1, then use a previous expression
                        if(st2 > 1) then
                            if(st1>0 .or. st3>0 .or. st4> 0) then
                            write(string5,'(I10)') st_deg_indices(2,st2) !it's variable 2 we're dealing with
                            string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                            string2 = trim(string2)//trim(aster)//trim(string6)
                            else !use a lower degree expression

                            if(pars%GAF_basis(1,func_ind)<=2) then !standard pol
                            write(string5,'(I10)') st_deg_indices(2,st2-1) !it's variable 2 we're dealing with
                            string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                            string2 = trim(string2)//trim(aster)//trim(string6)//'*'//trim(GAF_states(2))

                            else  !Cheb pol
                                !If the degree is two, then the constant term (deg - 2) is not saved anywhere. In this
                                !case just write it manually. Otherwise get value of T_{-2} from previous expressions.
                                if(st2 > 2) then
                                    write(string5,'(I10)') st_deg_indices(2,st2-2)
                                else
                                    write(string5,'(I10)') 1 !element with index one constains the constant term
                                end if
                                write(string7,'(I10)') st_deg_indices(2,st2-1)
                                !string5 contains index term 2 degrees lower, string 7 one degree lower
                                !Get the actual terms (in string6 and string7)
                                string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                                string7 = trim(GAF_names(func_ind))//'('//trim(adjustl(string7))//')'
                                string2 = trim(string2)//trim(aster)//'2*'//trim(string7)//'*'//trim(GAF_states(2))&
                                //'-'//trim(string6)
                            end if


                            end if
                            string3 = trim(string3)//trim(aster)//trim(GAF_states(2))//'**'//trim(adjustl(string4))

                        else !don't use a previous expression.
                            string2 = trim(string2)//trim(aster)//trim(GAF_states(2))!//'**'//trim(adjustl(string4))
                            string3 = trim(string3)//trim(aster)//trim(GAF_states(2))
                        end if
                        aster = '*'
                    end if

                    if(st3 > 0) then
                        write(string4,'(I10)') st3
                        !if degree>1, then use a previous expression
                        if(st3 > 1) then
                            if(st1>0 .or. st2>0 .or. st4> 0) then
                            write(string5,'(I10)') st_deg_indices(3,st3) !it's variable 3 we're dealing with
                            string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                            string2 = trim(string2)//trim(aster)//trim(string6)
                            else

                            if(pars%GAF_basis(1,func_ind)<=2) then !standard pol
                            write(string5,'(I10)') st_deg_indices(3,st3-1) !it's variable 3 we're dealing with
                            string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                            string2 = trim(string2)//trim(aster)//trim(string6)//'*'//trim(GAF_states(3))
                            else  !Cheb pol
                                !If the degree is two, then the constant term (deg - 2) is not saved anywhere. In this
                                !case just write it manually. Otherwise get value of T_{-2} from previous expressions.
                                if(st3 > 2) then
                                    write(string5,'(I10)') st_deg_indices(3,st3-2)
                                else
                                    write(string5,'(I10)') 1 !element with index one constains the constant term
                                end if
                                write(string7,'(I10)') st_deg_indices(3,st3-1)
                                !string5 contains index term 2 degrees lower, string 7 one degree lower
                                !Get the actual terms (in string6 and string7)
                                string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                                string7 = trim(GAF_names(func_ind))//'('//trim(adjustl(string7))//')'
                                string2 = trim(string2)//trim(aster)//'2*'//trim(string7)//'*'//trim(GAF_states(3))&
                                //'-'//trim(string6)
                            end if

                            end if
                            string3 = trim(string3)//trim(aster)//trim(GAF_states(3))//'**'//trim(adjustl(string4))

                        else !don't use a previous expression.
                            string2 = trim(string2)//trim(aster)//trim(GAF_states(3))!//'**'//trim(adjustl(string4))
                            string3 = trim(string3)//trim(aster)//trim(GAF_states(3))
                        end if
                        aster = '*'
                    end if

                    if(st4 > 0) then
                        write(string4,'(I10)') st4
                        !if degree>1, then use a previous expression
                        if(st4 > 1) then
                            if(st1>0 .or. st2>0 .or. st3> 0) then
                            write(string5,'(I10)') st_deg_indices(4,st4) !it's variable 4 we're dealing with
                            string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                            string2 = trim(string2)//trim(aster)//trim(string6)
                            else
                            if(pars%GAF_basis(1,func_ind)<=2) then !standard pol
                            write(string5,'(I10)') st_deg_indices(4,st4-1) !it's variable 4 we're dealing with
                            string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                            string2 = trim(string2)//trim(aster)//trim(string6)//'*'//trim(GAF_states(4))
                            else  !Cheb pol
                                !If the degree is two, then the constant term (deg - 2) is not saved anywhere. In this
                                !case just write it manually. Otherwise get value of T_{-2} from previous expressions.
                                if(st4 > 2) then
                                    write(string5,'(I10)') st_deg_indices(4,st4-2)
                                else
                                    write(string5,'(I10)') 1 !element with index one constains the constant term
                                end if
                                write(string7,'(I10)') st_deg_indices(4,st4-1)
                                !string5 contains index term 2 degrees lower, string 7 one degree lower
                                !Get the actual terms (in string6 and string7)
                                string6 = trim(GAF_names(func_ind))//'('//trim(adjustl(string5))//')'
                                string7 = trim(GAF_names(func_ind))//'('//trim(adjustl(string7))//')'
                                string2 = trim(string2)//trim(aster)//'2*'//trim(string7)//'*'//trim(GAF_states(4))&
                                //'-'//trim(string6)
                            end if

                            end if
                            string3 = trim(string3)//trim(aster)//trim(GAF_states(4))//'**'//trim(adjustl(string4))
                        else !don't use a previous expression.
                            string2 = trim(string2)//trim(aster)//trim(GAF_states(4))!//'**'//trim(adjustl(string4))
                            string3 = trim(string3)//trim(aster)//trim(GAF_states(4))
                        end if
                        aster = '*'
                    end if

                    !If all the indices are zero, it's the constant term:
                    if(max(st1,st2,st3,st4) == 0) then
                        string2 = '1.0_dp !constant term'
                        string3 = ''

                    end if

                    if(i_img == spec_img) then
                        write(21,'(A)') trim(string1)//' '//trim(string2)//trim(string3)
                    end if

                    exp_var_ind = exp_var_ind + 1

                556 end do
                end do
                end do
                end do

            case default
                if(i_img == spec_img) then
                    write(*,*) 'Write: Implement Chebyshev Polynomials basis in mod_gen_mod_V_reg.f90'
                    write(*,*) 'Follow notes in H&M appendix (approximate using OLS, not the collocation method)'
                    write(*,*) 'Continue on line 395 in mod_gen_mod_V_reg.f90'
                    error stop
                end if
        end select


            write(21,'(A)') ' '
            write(21,'(A)') 'end function '//trim(GAF_names(func_ind))
            write(21,'(A)') ' '


        deallocate(st_deg_indices)

    end do !(func_ind)

    end if !(if i_img == spec_img)

    !******************************************************
    !HERE: generate the feature scaling functions (even if the value of GAF_FS is 0,
    !still generate them - they will just not change anything).
    !******************************************************
    if(i_img == spec_img) then
        write(21,'(A)') ' '
        write(21,'(A)') '!The following functions are used to scale features.'
        write(21,'(A)') '!This is extremely important for speed of convergence in iterative algorithms'
        write(21,'(A)') '!like gradient descent. If use_FS is false (which is set in parameter file,'
        write(21,'(A)') '!then these functions do not change anything.'
        write(21,'(A)') ' '
    end if

    do func_ind = 1,shape_GAF_deg(1) !cycle over functions to be approximated
        !Generate interface (this does not depend on the basis)

        string1 = 'function '//trim(GAF_names(func_ind))//'_FS('
        string1 = trim(string1)//'st_exp,use_FS)'

        if(i_img == spec_img) then
        write(21,'(A)') trim(string1)



        !Finish generating the interface here:
        !Because of slight inconsistency in notation, write the first part manually
        if(func_ind == 1) then
            write(21,'(A)') '   real(dp), dimension(V_exp_num) :: '//trim(GAF_names(func_ind))//'_FS'
            write(21,'(A)') '   real(dp), dimension(V_exp_num), intent(in) :: st_exp !vector of exp vars before scaling'
        else
            write(21,'(A)') '   real(dp), dimension(V_exp_num_dyn) :: '//trim(GAF_names(func_ind))//'_FS'
            write(21,'(A)') '   real(dp), dimension(V_exp_num_dyn), intent(in) :: st_exp !vector of exp vars before scaling'
        end if
        write(21,'(A)') '   logical :: use_FS !If false, no scaling is done.'
        write(21,'(A)') ' '


        !If we're using Cheb pol, then do not do anything (as in don't generate the code
        !for feature scaling, and always return the unchanged value. Otherwise do not preform any feature scaling if
        !not use_FS (which is then checked at runtime).
        if(pars%GAF_basis(1,func_ind) == 3 .or. pars%GAF_basis(1,func_ind) == 4) then
            write(21,'(A)') '       '//trim(GAF_names(func_ind))//'_FS = st_exp'
            write(21,'(A)') '       return'
        else
            write(21,'(A)') '   if(.not. use_FS) then'
            write(21,'(A)') '       '//trim(GAF_names(func_ind))//'_FS = st_exp'
            write(21,'(A)') '       return'
            write(21,'(A)') '   end if'
            write(21,'(A)') ''
        end if

        end if

        !Find the maximum degree of polynomial included.
        max_deg = maxval(reshape(pars%GAF_deg(func_ind,:),[4]))

        exp_var_ind = 1 !initialize states counter

        select case(pars%GAF_basis(1,func_ind))
            case(1,2) !tensor product or complete polynomials.

                do st4=0,pars%GAF_deg(func_ind,4)
                do st3=0,pars%GAF_deg(func_ind,3)
                do st2=0,pars%GAF_deg(func_ind,2)
                do st1=0,pars%GAF_deg(func_ind,1)

                    !If the order of the polynomial in interaction term is larger
                    !than GAF_inter_deg, don't increase the number go to 557:

                    !If complete polynomials, also check that the sum of degrees is not greater than K,
                    !where K is the largest individual degree (max_deg). If yes, then skip to the next
                    !candidate combination (go to 557)
                    if(pars%GAF_basis(1,func_ind)==2 .and. (st1 + st2 + st3 + st4) > max_deg) go to 557

                    !If at least 2 of the degrees are positive, check the restriction on order of interaction
                    !term
                    if(sum([L_to_I(st1>0),L_to_I(st2>0),L_to_I(st3>0),L_to_I(st4>0)]) > 1) then

                        !the -1 value means no restriction. If any of the restrictions is violated, go to 556
                        if(any([st1>pars%GAF_inter_deg(func_ind,1) .and. pars%GAF_inter_deg(func_ind,1) > -1,&
                        st2>pars%GAF_inter_deg(func_ind,2) .and. pars%GAF_inter_deg(func_ind,2) > -1,&
                        st3>pars%GAF_inter_deg(func_ind,3) .and. pars%GAF_inter_deg(func_ind,3) > -1,&
                        st4>pars%GAF_inter_deg(func_ind,4) .and. pars%GAF_inter_deg(func_ind,4) > -1])) then
                            go to 557
                        end if
                    end if


                    !FIRST compute the statistics that we need for scaling
                    FS_mean = 0.0_dp; FS_norm = 0.0_dp !initialize statistics
                    fs_min = 100000000000000000.0_dp
                    fs_max = -100000000000000000.0_dp
                    !degrees are st1,st2,st3,st4 (of a1,a2,rho,t)
                    do gp_ind = min_ind_img,max_ind_img
                        !Value of feature (explanatory variable) at this gridpoint.
                        y_val = (st_und_img(1,gp_ind)**st1) * & !a1
                        (st_und_img(2,gp_ind)**st2) * & !a2
                        (st_und_img(3,gp_ind)**st3) * & !rho
                        (st_und_img(4,gp_ind)**st4) !t

                        FS_mean = FS_mean + y_val
                        fs_min = min(fs_min,y_val)
                        fs_max = max(fs_max,y_val)
                    end do

!                    sync all
!                    write(*,*) 'fs_min =',fs_min,'i_img = ',i_img
!                    write(*,*) 'fs_max =',fs_max,'i_img = ',i_img
                    sync all

                    if(i_img == 1) then
                        fs_mean = fs_mean/(V_num_el/M_par)
                        do img_ind = 2,num_images()
                            fs_mean = fs_mean + fs_mean[img_ind]/(V_num_el/M_par)

                            fs_min = min(fs_min,fs_min[img_ind])
                            fs_max = max(fs_max,fs_max[img_ind])
                        end do
!                        write(*,*) 'fs_min =',fs_min
!                        write(*,*) 'fs_max =',fs_max
!                        write(*,*) 'fs_mean =',fs_mean
                    end if
                    sync all

                    !if GAF_FS = 2 or 4, the normalization is by standard deviation, otherwise it's by range
                    if(pars%GAF_FS == 2 .or. pars%GAF_FS == 4) then
                        FS_mean = FS_mean[1]
                        FS_norm = 0.0_dp
                        do gp_ind = min_ind_img,max_ind_img
                            !Value of feature (explanatory variable) at this gridpoint.
                            y_val = (st_und_img(1,gp_ind)**st1) * & !a1
                                (st_und_img(2,gp_ind)**st2) * & !a2
                                (st_und_img(3,gp_ind)**st3) * & !rho
                                (st_und_img(4,gp_ind)**st4) !t

                            FS_norm = FS_norm + (y_val - FS_mean)**2.0_dp
                        end do
                        sync all
                        do img_ind = 2,num_images()
                            fs_norm = fs_norm + fs_norm[img_ind]/(V_num_el/M_par)
                        end do
                        fs_norm = sqrt(fs_norm)
                    else
                        fs_norm = fs_max - fs_min
                    end if

!                    if(i_img == 1) then
!                        write(*,*) 'fs_norm = ', fs_norm
!                    end if
                    sync all
                    !AFTER this point, image 1 should have all the statistics needed for scaling

                    write(string2,'(I10)') exp_var_ind
                    string1 = '   '//trim(GAF_names(func_ind))//'_FS('//trim(adjustl(string2))//') = ('//&
                    'st_exp('//trim(adjustl(string2))//')'

                    !If demeaning, subtract mean (unless it's the first term which is the constant term)
                    if((pars%GAF_FS == 3 .or. pars%GAF_FS == 4) .and. exp_var_ind > 1) then
                        if(abs(FS_mean) < 1000000.0_dp) then
                            write(string2,'(F10.3)') FS_mean
                        else
                            write(string2,*) FS_mean
                        end if
                        string1 = trim(string1)//' - '//trim(adjustl(string2))//'_dp)'
                    else
                        string1 = trim(string1)//')'
                    end if

                    !Normalizing, divide by FS_norm (this is either range or std. deviation)
                    !(already was distinguished above). As before don't normalize the constant term.
                    !Don't normalize by a number lower than 10E-07, otherwise we might get NaNs
                    !at some stage. This tiny norm could result if we include high degree of polynomials
                    !of rho).
                    FS_norm = max(FS_norm,0.0000000000001_dp)
                    if(abs(FS_norm) < 10000000.0_dp) then
                        !write(string2,'(F15.7)') FS_norm
                        !Writing unformatted output and very low norm might help (in case
                        !we have high order polynomial of rho).
                        write(string2,*) FS_norm
                    else
                        write(string2,*) FS_norm
                    end if
                    if(exp_var_ind > 1) then
                        string1 = trim(string1)//'/'//trim(adjustl(string2))//'_dp'
                    end if

                    if(i_img == spec_img) then
                        write(21,'(A)') trim(string1)
                    end if

                    exp_var_ind = exp_var_ind + 1

                557 end do
                end do
                end do
                end do

            case(3,4)
            !We are using Chebyshev Polynomials - in this case no feature scaling done because they are already all
            !in (-1,1) interval.

        end select

        558 if(i_img == spec_img) then

            write(21,'(A)') ' '
            write(21,'(A)') 'end function '//trim(GAF_names(func_ind))//'_FS'
            write(21,'(A)') ' '

        end if


    end do !(func_ind)

    !______________________________________________________
    !END of generating feature scaling subroutines.
    !_______________________________________________________

    if(i_img == spec_img) then

    write(21,'(A)') ' '
    write(21,'(A)') '!Note: no interpolation over shock realizations (discrete Markov chain). Dummy variables introduced for'
    write(21,'(A)') '!each possible realization (so we essentially treat these as separate functions).'
    write(21,'(A)') ' '

    write(21,'(A)') '!Function V_eval evaluates the approximated value function. Inputs are coefficients (V_coeff) in the'
    write(21,'(A)') '!regression approximation as column vector, and a value of states (obtained as output of subroutine V_und_exp).'
    write(21,'(A)') '!These inputs need to be of the same dimension (no check done for performance considerations - this function is'
    write(21,'(A)') '!very deep in the program).'
    write(21,'(A)') ' '

    write(21,'(A)') 'function V_eval(V_coeff,st_exp)'
    write(21,'(A)') '   real(dp) :: V_eval !experiment'
    write(21,'(A)') '   real(dp), dimension(:), intent(in) :: st_exp !generated by function V_und_exp'
    write(21,'(A)') '   real(dp), dimension(:,:), intent(in) :: V_coeff !coefficients stored in column vector'
    write(21,'(A)') ' '
    write(21,'(A)') '   V_eval = dot_product(st_exp,reshape(V_coeff,shape(st_exp)))'
    write(21,'(A)') 'end function V_eval'



    !From this function, call all functions approx gen for each approximating function (row
    !of GAF_names). For now appeox_gen will just generate the function text (including the
    !interface), and save it in .f90 files with the names in the appropriate row of
    !GAF_names.
    !
    !Later on (extension for convenient use at HPC), the function will return a character
    !array containing the whole function including the interface (and the number of
    !explanatory variables), and the whole module V_mod_reg will be generated. That is,
    !if the concept is shown to work (and can be expected to be worth doing this extension).
    !
    !If something is unclear check notes in Google drive and also in baseline.txt

    !open(unit=21, file = trim(full_path), status = 'unknown', position = 'append')
    write(21,'(A)') 'end module mod_V_reg'
    close(unit=21)

    end if !(if i_img == spec_img)

end subroutine gen_mod_V_reg


end module mod_gen_mod_V_reg
